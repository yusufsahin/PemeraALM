import { inject, injectable } from 'inversify';
import bcrypt from 'bcryptjs';
import { IUserService } from '../abstract/IUserService';
import { IUserDTO } from '../../dto/IUserDTO';
import { IUser, User } from '../../models/User';
import {UserRepository} from "../../repositorites/concrete/UserRepository";
import {RoleRepository} from "../../repositorites/concrete/RoleRepository";



@injectable()
export class UserService implements IUserService {
    constructor(
        @inject('IUserRepository') private userRepository: UserRepository,
        @inject('IRoleRepository') private roleRepository: RoleRepository
    ) {}

    public async createUser(userDTO: IUserDTO): Promise<IUserDTO> {
        // Auto-generate a password and hash it
        const autoGeneratedPassword = this.generatePassword();
        const hashedPassword = await bcrypt.hash(autoGeneratedPassword, 10);

        // Find the "Member" role in the database
        const memberRole = await this.roleRepository.findOne({ name: 'Members' });

        // Create a new user instance using the Mongoose model
        const newUser = new User({
            username: userDTO.username || '',  // Ensure username is a string
            firstname: userDTO.firstname || '', // Ensure firstname is a string
            lastname: userDTO.lastname || '',  // Ensure lastname is a string
            email: userDTO.email || '',        // Ensure email is a string
            password: hashedPassword,          // Store the hashed password
            roles: memberRole ? [memberRole._id] : [], // Assign the "Members" role by default
        });

        const user = await this.userRepository.create(newUser);
        return this.toDTO(user);
    }

    public async updateUser(userId: string, updateData: IUserDTO): Promise<IUserDTO | null> {
        const updatedUser = await this.userRepository.updateById(userId, {
            username: updateData.username || '',  // Ensure username is a string
            firstname: updateData.firstname || '', // Ensure firstname is a string
            lastname: updateData.lastname || '',  // Ensure lastname is a string
            email: updateData.email || '',        // Ensure email is a string
        } as Partial<IUser>);
        return updatedUser ? this.toDTO(updatedUser) : null;
    }

    public async getUserById(userId: string): Promise<IUserDTO | null> {
        const user = await this.userRepository.findById(userId);
        return user ? this.toDTO(user) : null;
    }

    public async listAllUsers(): Promise<IUserDTO[]> {
        const users = await this.userRepository.findAll();
        return users.map(this.toDTO);
    }

    public async deleteUser(userId: string): Promise<void> {
        await this.userRepository.deleteById(userId);
    }

    private toDTO(user: IUser): IUserDTO {
        return {
            _id: user._id.toHexString(),
            id: user._id.toHexString(),
            username: user.username,
            firstname: user.firstname,
            lastname: user.lastname,
            email: user.email,
        };
    }

    private generatePassword(): string {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let password = '';
        for (let i = 0; i < 12; i++) {
            password += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return password;
    }
}
